name: Build

on:
  push:
    branches:
      - "main"
      - "alpha"
      - "beta"
  pull_request:

jobs:
  build:
    name: Build
    runs-on: windows-2025
    concurrency:
      group: ukcp-build-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - name: Checkout Code and Submodules
        uses: actions/checkout@v4
        with:
          submodules: recursive

      # Environment things
      - name: Set up Visual Studio Shell
        uses: egor-tensin/vs-shell@v2
        with:
          arch: x86

      - name: Check Clang Version
        run: clang-cl --version

      - name: Setup Ninja
        uses: seanmiddleditch/gha-setup-ninja@master

      # cURL
      - name: Cache cURL
        id: cache-curl
        uses: actions/cache@v4
        with:
          path: "C:\\hostedtoolcache\\windows\\libcurl"
          key: "ukcp-curl-build"

      - name: Download and Build cURL
        if: steps.cache-curl.outputs.cache-hit != 'true'
        env:
          CURL_DOWNLOAD_URL: "https://github.com/curl/curl/releases/download/curl-7_76_1/curl-7.76.1.zip"
          CURL_VERSION: 7.76.1
        run: |
          New-Item -Path "C:\\hostedtoolcache\\windows" -Name "libcurl" -ItemType "directory"
          $WebClient = New-Object System.Net.WebClient
          $WebClient.DownloadFile(${env:CURL_DOWNLOAD_URL}, "C:\\hostedtoolcache\\windows\\libcurl\\curl.zip")
          Set-Location -Path "C:\\hostedtoolcache\\windows\\libcurl"
          7z x curl.zip
          Remove-Item curl.zip
          Set-Location -Path "C:\\hostedtoolcache\\windows\\libcurl\\curl-${env:CURL_VERSION}\\winbuild"
          nmake /f Makefile.vc mode=static ENABLE_SCHANNEL=yes

      - name: Setup cURL Environment
        env:
          CURL_VERSION: 7.76.1
        run: |
          echo "CURL_INCLUDEDIR=C:\\hostedtoolcache\\windows\\libcurl\\curl-${env:CURL_VERSION}\\builds\\libcurl-vc-x86-release-static-ipv6-sspi-schannel\\include" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "CURL_LIBRARYDIR=C:\\hostedtoolcache\\windows\\libcurl\\curl-${env:CURL_VERSION}\\builds\\libcurl-vc-x86-release-static-ipv6-sspi-schannel\\lib" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      # Setup all the yarn things and node modules
      - name: Setup Yarn
        uses: actions/setup-node@v4
        with:
          node-version: "16"

      - name: Get Yarn Cache Directory
        id: yarn-cache-dir-path
        run: echo "::set-output name=dir::$(yarn cache dir)"

      - name: Load Yarn Cache
        uses: actions/cache@v4
        id: yarn-cache
        with:
          path: ${{ steps.yarn-cache-dir-path.outputs.dir }}
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-yarn-

      - name: Load Cached Node Modules
        uses: actions/cache@v4
        with:
          path: "**/node_modules"
          key: ${{ runner.os }}-node-modules-${{ hashFiles('**/yarn.lock') }}

      # Install yarn things
      - name: Install Assets
        run: yarn

      - name: Setup Build Version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: .\\.github\\workflows\\plugin_version.ps1

      - name: Run CMake
        env:
          CC: clang-cl
          CFLAGS: -m32
          CXX: clang-cl
          CXXFLAGS: -m32
        run: cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -G Ninja -Bbuild

      # Run the build and tests
      - name: Run Ninja Build
        working-directory: build
        run: ninja

      - name: Check Test Dependencies
        working-directory: build
        run: |
          Write-Host "=== Checking DLL dependencies and availability ==="

          # List files in bin directory
          Write-Host "`nFiles in bin directory:"
          Get-ChildItem bin\* | ForEach-Object { Write-Host "  $($_.Name)" }

          # Check if EuroScopePlugInDll.dll exists in bin
          if (Test-Path "bin\EuroScopePlugInDll.dll") {
            Write-Host "`nEuroScopePlugInDll.dll : EXISTS in bin directory" -ForegroundColor Green
          } else {
            Write-Host "`nEuroScopePlugInDll.dll : MISSING from bin directory" -ForegroundColor Red
          }

          # Check UKControllerPluginCoreTest.exe dependencies
          Write-Host "`n=== UKControllerPluginCoreTest.exe dependencies ==="
          dumpbin /dependents bin\UKControllerPluginCoreTest.exe

          # Parse and check all dependencies from the test executable
          Write-Host "`n=== Checking if all test dependencies are available (32-bit) ==="
          $testDeps = dumpbin /dependents bin\UKControllerPluginCoreTest.exe | Select-String "\.dll" | ForEach-Object { $_.Line.Trim() }

          foreach ($dll in $testDeps) {
            if ($dll -match "^[\w\-]+\.dll$") {
              # First check in bin directory
              if (Test-Path "bin\$dll") {
                Write-Host "  $dll : FOUND in bin directory" -ForegroundColor Green
              } else {
                # Check in system PATH and verify architectures
                $locations = where.exe $dll 2>&1
                if ($LASTEXITCODE -eq 0) {
                  $allLocations = ($locations -split "`n") | Where-Object { $_ -match "\.dll$" }
                  $found32bit = $false
                  $found64bit = $false

                  foreach ($location in $allLocations) {
                    # Check if it's 32-bit using dumpbin
                    $dumpOutput = dumpbin /headers $location 2>&1 | Select-String "machine"
                    if ($dumpOutput -match "\(x86\)") {
                      if (-not $found32bit) {
                        Write-Host "  $dll : FOUND 32-bit at $location" -ForegroundColor Green
                        $found32bit = $true
                      }
                    } elseif ($dumpOutput -match "x64") {
                      if (-not $found64bit) {
                        Write-Host "  $dll : FOUND 64-bit at $location" -ForegroundColor Yellow
                        $found64bit = $true
                      }
                    }
                  }

                  if (-not $found32bit -and -not $found64bit) {
                    Write-Host "  $dll : FOUND but architecture unknown at $($allLocations[0])"
                  } elseif (-not $found32bit) {
                    Write-Host "  $dll : WARNING - Only 64-bit version found, 32-bit needed!" -ForegroundColor Red
                  }
                } else {
                  Write-Host "  $dll : NOT FOUND" -ForegroundColor Red
                }
              }
            }
          }

          Write-Host "`n=== Checking Visual Studio x86 bin directory ==="
          $vsPath = "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC"
          if (Test-Path $vsPath) {
            $msvcVersions = Get-ChildItem $vsPath | Sort-Object -Descending | Select-Object -First 1
            $x86BinPath = Join-Path $msvcVersions.FullName "bin\Hostx86\x86"
            Write-Host "VS x86 bin path: $x86BinPath"
            if (Test-Path $x86BinPath) {
              Write-Host "Contents:"
              Get-ChildItem "$x86BinPath\*.dll" | ForEach-Object { Write-Host "  $($_.Name)" }
            }
          }

          Write-Host "`n=== Testing DLL loading manually ==="
          # Try to load each DLL that the test depends on
          Add-Type @"
            using System;
            using System.Runtime.InteropServices;
            public class DllLoader {
                [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
                public static extern IntPtr LoadLibrary(string lpFileName);

                [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
                public static extern bool FreeLibrary(IntPtr hModule);
            }
"@

          # Test loading the main DLLs in order
          $testDlls = @(
            "bin\EuroScopePlugInDll.dll",
            "bin\UKControllerPluginCore.dll"
          )

          foreach ($dllPath in $testDlls) {
            $fullPath = Resolve-Path $dllPath -ErrorAction SilentlyContinue
            if ($fullPath) {
              Write-Host "Testing load: $fullPath"
              $handle = [DllLoader]::LoadLibrary($fullPath)
              if ($handle -eq [IntPtr]::Zero) {
                $error = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
                Write-Host "  FAILED to load: Error code $error (0x$($error.ToString('X')))" -ForegroundColor Red

                # Common error codes
                if ($error -eq 126) { Write-Host "    Error 126: The specified module could not be found (a dependency is missing)" }
                if ($error -eq 127) { Write-Host "    Error 127: The specified procedure could not be found" }
              } else {
                Write-Host "  SUCCESS: Loaded successfully" -ForegroundColor Green
                [DllLoader]::FreeLibrary($handle) | Out-Null
              }
            }
          }

      - name: Run Tests
        working-directory: build
        run: |
          Write-Host "=== Running from directory: $(Get-Location) ==="

          # Find Visual Studio x86 runtime DLLs directory
          $vsPath = "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC"
          $msvcVersion = Get-ChildItem $vsPath | Sort-Object -Descending | Select-Object -First 1
          $x86BinPath = Join-Path $msvcVersion.FullName "bin\Hostx86\x86"

          Write-Host "Visual Studio x86 bin path: $x86BinPath"

          # Add both bin directory and VS x86 runtime to PATH
          $env:PATH = "$(Get-Location)\bin;$x86BinPath;$env:PATH"
          Write-Host "Updated PATH to include bin and VS x86 runtime"

          ctest -C Release --output-on-failure --no-tests=error

      # Do Srclinting
      - name: Get Changed Files (Src)
        id: changed-files-src
        uses: Ana06/get-changed-files@v2.3.0
        with:
          filter: |
            src/**/*.cpp

      - name: Clang Tidy (Src)
        continue-on-error: true # Have to as clang-tidy doesnt want to run properly on Windows
        if: false
        run: |
          if (-not ([string]::IsNullOrEmpty("${{ steps.changed-files-src.outputs.added_modified }}"))) { clang-tidy ${{ steps.changed-files-src.outputs.added_modified }} -p build }

      # Upload artifacts
      - name: Upload Core Binary As Artifact
        uses: actions/upload-artifact@v4
        with:
          name: UKControllerPluginCore.dll
          path: ".\\build\\bin\\UKControllerPluginCore.dll"

      - name: Upload Updater Binary As Artifact
        uses: actions/upload-artifact@v4
        with:
          name: UKControllerPluginUpdater.dll
          path: ".\\build\\bin\\UKControllerPluginUpdater.dll"

      - name: Upload Loader Binary As Artifact
        uses: actions/upload-artifact@v4
        with:
          name: UKControllerPlugin.dll
          path: ".\\build\\bin\\UKControllerPlugin.dll"

  format:
    name: Format
    runs-on: windows-latest
    concurrency:
      group: ukcp-format-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      # Environment things
      - name: Check Clang Version
        run: clang-cl --version

      - name: Get All Changed Files
        id: changed-files
        uses: Ana06/get-changed-files@v2.3.0
        with:
          filter: |
            src/**/*.cpp
            src/**/*.h
            test/**/*.cpp
            test/**/*.h

      - name: Clang Format
        run: |
          if (-not ([string]::IsNullOrEmpty("${{ steps.changed-files.outputs.added_modified }}"))) { clang-format --style=file --dry-run -Werror ${{ steps.changed-files.outputs.added_modified }} }

  release:
    name: Release
    runs-on: windows-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/beta' || github.ref == 'refs/heads/alpha')
    needs: [build, format]
    concurrency:
      group: ukcp-release
      cancel-in-progress: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      # Setup all the yarn things and node modules
      - name: Setup Yarn
        uses: actions/setup-node@v4
        with:
          node-version: "16"

      - name: Get Yarn Cache Directory
        id: yarn-cache-dir-path
        run: echo "::set-output name=dir::$(yarn cache dir)"

      - name: Load Yarn Cache
        uses: actions/cache@v4
        id: yarn-cache
        with:
          path: ${{ steps.yarn-cache-dir-path.outputs.dir }}
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-yarn-

      - name: Load Cached Node Modules
        uses: actions/cache@v4
        with:
          path: "**/node_modules"
          key: ${{ runner.os }}-node-modules-${{ hashFiles('**/yarn.lock') }}

      # Install yarn things
      - name: Install Assets
        run: yarn

      # Download build artifacts
      - name: Download Core Binary
        uses: actions/download-artifact@v4
        with:
          name: UKControllerPluginCore.dll
          path: ".\\build\\bin\\UKControllerPluginCore.dll"

      - name: Download Updater Binary
        uses: actions/download-artifact@v4
        with:
          name: UKControllerPluginUpdater.dll
          path: ".\\build\\bin\\UKControllerPluginUpdater.dll"

      - name: Download Loader Binary
        uses: actions/download-artifact@v4
        with:
          name: UKControllerPlugin.dll
          path: ".\\build\\bin\\UKControllerPlugin.dll"

      - name: Create Release
        env:
          GITHUB_TOKEN: ${{ secrets.PAT }}
          GH_TOKEN: ${{ secrets.PAT }}
        run: |
          yarn semantic-release
